%{/* -*- mode: c; c-basic-offset: 4; -*-

Copyright (C) 2015, cPanel Inc
Copyright (C) 2017, Reini Urban <rurban@cpan.org>

=head1 NAME

ext/warnings/warnings.xs - gperf generated read-only warnings hash as shared library

=head1 DESCRIPTION

Generated warnings hash from F<ext/warnings/warnings_xs.in>
via F<ext/warnings/warnings_xs.PL>

C<gperf --output-file=ext/warnings/warnings.xs ext/warnings/warnings_xs.in>
with cleanups for header, inline, C++ and c89.

The old external hashes C<%Bits>, C<%DeadBits> are tied to the
values in the const wordlist perfect hash.  Only the C<all> key is
writable, but the hash is extendable.  Every read-access goes first
through the perfect hash, and then into a normal perl hash, to be able
to register custom user-categories. We assume almost nobody needs to
create his own user category, so penalize this.

For "all", if C<%_Bits> exists, i.e. user category warnings were added, 
"all is taken from there, otherwise from the initial const hash.

=over 4

=item C<struct Perl_warnings>

Structure of generated read-only hash table with name, offsets, bits and deadbits.

=back

=head2 Functions

=over 4

=item C<struct Perl_warnings * Perl_warnings_lookup(register const
char *str, register unsigned int len)>

API function to access the generated hash.

=item C<struct Perl_warnings * warnings_const_lookup(register const
char *str, register unsigned int len)>

Generated lookup function to access to read-only compile-time part of the hash.

=back

=cut

*/

#define PERL_NO_GET_CONTEXT
#define PERL_EXT
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "warnings.h"

#define USE_PP_CARP 1
#define WNORMAL  1
#define WFATAL   2
#define WMESSAGE 4

typedef UV HASHOBJ;
#define AV_PUSH(av, val) av_store(av, AvFILLp(av)+1, val)

struct Perl_warnings { int name; const U8 offset; const char *bits; const char *deadbits; };
struct Perl_warnings_dyn { int name; U8 offset; char *bits; char *deadbits; SV *base; };
struct Perl_warnings_dyn ws;
struct Perl_warnings_dyn wall;
struct Perl_warnings *
Perl_warnings_lookup (register const char *str, register unsigned int len);

%}
%language=ANSI-C
%struct-type
%define hash-function-name   warnings_hash
%define lookup-function-name warnings_const_lookup
%null-strings
%pic
%readonly-tables

struct Perl_warnings;
%%
all, 0, WARN_ALLstring, WARN_DEADALLstring
closure, 2, "\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
deprecated, 4, "\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
exiting, 6, "\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
glob, 8, "\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
io, 10, "\0\124\125\0\0\0\0\0\0\0\0\0\0\0\100\0\0\0", "\0\250\252\0\0\0\0\0\0\0\0\0\0\0\200\0\0\0"
closed, 12, "\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
exec, 14, "\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
layer, 16, "\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
newline, 18, "\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
pipe, 20, "\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
unopened, 22, "\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
misc, 24, "\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
numeric, 26, "\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
once, 28, "\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
overflow, 30, "\0\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
pack, 32, "\0\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0"
portable, 34, "\0\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\10\0\0\0\0\0\0\0\0\0\0\0\0\0"
recursion, 36, "\0\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0"
redefine, 38, "\0\0\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0"
regexp, 40, "\0\0\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0"
severe, 42, "\0\0\0\0\0\124\5\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\250\12\0\0\0\0\0\0\0\0\0\0\0"
debugging, 44, "\0\0\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0"
inplace, 46, "\0\0\0\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0"
internal, 48, "\0\0\0\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0"
malloc, 50, "\0\0\0\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\10\0\0\0\0\0\0\0\0\0\0\0"
signal, 52, "\0\0\0\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0"
substr, 54, "\0\0\0\0\0\0\100\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\200\0\0\0\0\0\0\0\0\0\0\0"
syntax, 56, "\0\0\0\0\0\0\0\125\125\25\0\100\0\0\0\0\0\0", "\0\0\0\0\0\0\0\252\252\52\0\200\0\0\0\0\0\0"
ambiguous, 58, "\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\0\0\0"
bareword, 60, "\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\40\0\0\0\0\0\0\0\0\0\0"
digit, 62, "\0\0\0\0\0\0\0\100\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\200\0\0\0\0\0\0\0\0\0\0"
parenthesis, 64, "\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0"
precedence, 66, "\0\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\0\0"
printf, 68, "\0\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\40\0\0\0\0\0\0\0\0\0"
prototype, 70, "\0\0\0\0\0\0\0\0\100\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\200\0\0\0\0\0\0\0\0\0"
qw, 72, "\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0"
reserved, 74, "\0\0\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\0"
semicolon, 76, "\0\0\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\40\0\0\0\0\0\0\0\0"
taint, 78, "\0\0\0\0\0\0\0\0\0\100\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\200\0\0\0\0\0\0\0\0"
threads, 80, "\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0"
uninitialized, 82, "\0\0\0\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0"
unpack, 84, "\0\0\0\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\40\0\0\0\0\0\0\0"
untie, 86, "\0\0\0\0\0\0\0\0\0\0\100\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\200\0\0\0\0\0\0\0"
utf8, 88, "\0\0\0\0\0\0\0\0\0\0\0\1\25\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\2\52\0\0\0\0\0"
void, 90, "\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0"
imprecision, 92, "\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\40\0\0\0\0\0\0"
illegalproto, 94, "\0\0\0\0\0\0\0\0\0\0\0\100\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\200\0\0\0\0\0\0"
non_unicode, 96, "\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\2\0\0\0\0\0"
nonchar, 98, "\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0"
surrogate, 100, "\0\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\40\0\0\0\0\0"
experimental, 102, "\0\0\0\0\0\0\0\0\0\0\0\0\100\125\25\125\1\4", "\0\0\0\0\0\0\0\0\0\0\0\0\200\252\52\252\2\10"
experimental::lexical_subs, 104, "\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\2\0\0\0\0"
experimental::lexical_topic, 106, "\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0"
experimental::regex_sets, 108, "\0\0\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\40\0\0\0\0"
experimental::smartmatch, 110, "\0\0\0\0\0\0\0\0\0\0\0\0\0\100\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\200\0\0\0\0"
experimental::autoderef, 112, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2\0\0\0"
experimental::postderef, 114, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0"
experimental::signatures, 116, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\40\0\0\0"
syscalls, 118, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\100\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\200\0\0\0"
experimental::bitwise, 120, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2\0\0"
experimental::const_attr, 122, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0"
experimental::re_strict, 124, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\20\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\40\0\0"
experimental::refaliasing, 126, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\100\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\200\0\0"
experimental::win32_perlio, 128, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2\0"
locale, 130, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0"
missing, 132, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\20\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\40\0"
redundant, 134, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\100\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\200\0"
types, 136, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2"
experimental::declared_refs, 138, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10"
security, 140, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\20", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\40"
%%

/* We really need to zero the bits */
static SV *
newWSV(const char *str, const int len) {
    int nlen = len ? len : WARN_MAX_BYTES;
    SV *sv = newSV(nlen);
    /*SvUPGRADE(sv, SVt_PV); --unneeded*/
    SvCUR_set(sv, nlen);
    SvPOK_on(sv);
    Zero(SvPVX(sv), nlen, char);
    if (len)
        Move(str, SvPVX(sv), len, char);
    return sv;
}

/* static compile-time length */
#define newWSVpvs(str) newWSV(STR_WITH_LEN(str))
/* dynamic max length */
#define newWSVpv(str) newWSV(str, WARN_MAX_BYTES)
/* static length from header */
#define newWSVpvh(str) newWSV(str, WARNsize)

struct Perl_warnings *
Perl_warnings_lookup (register const char *str, register unsigned int len) {
    const struct Perl_warnings *w = warnings_const_lookup(str, len);
    const bool is_all = memEQs(str, len, "all");
    if (is_all || !w) {
        SV **bit;
        HV * const bits = get_hv("warnings::_Bits", 0);
        if (bits && HvTOTALKEYS(bits)) {
            SvREADONLY_off(bits);
            if ((bit = hv_fetch(bits, str, len, FALSE))) {
                char *p = SvPVX(*bit);
                /* use the static temp. buffer */
                struct Perl_warnings_dyn *wd = is_all ? &wall : &ws;
                STRLEN l = SvCUR(*bit) / 2;
                wd->offset   = SvIVX(*bit);
                wd->bits     = p;
                wd->deadbits = p + l;
                wd->base     = *bit;
                SvREADONLY_on(bits);
                return (struct Perl_warnings *)wd;
            }
            SvREADONLY_on(bits);
        } else if (is_all) { /* old all */
            return (struct Perl_warnings *)w;
        } else {
            return NULL;
        }
    }
    return (struct Perl_warnings *)w;
}

static int _chk(const char *sub, const U32 flags, I32 ax) {
    dSP;
    SV **mark = PL_stack_base + ax - 1;
    dITEMS;
    SV *message, *mask;
    char *category;
    const struct Perl_warnings *w;
    const PERL_CONTEXT *cx;
    int i, is_obj = 0;
    int has_message = flags & WMESSAGE;
    int results_0 = 0, results_1 = 0;
    STRLEN * old_warnings;

    if (!(items == 1 || items == (has_message ? 2 : 0))) {
#ifdef USE_PP_CARP
        SV *msg = newSVpvs("");
        sv_catpvf(msg, "Usage: warnings::%s(%s)", sub, has_message ? "[category,] 'message'" : "[category]");
        PUSHMARK(SP);
        mXPUSHs(msg);
        PUTBACK;
        call_pv("warnings::Croaker", G_DISCARD);
        SPAGAIN;
#else
        /*croak_sv(carp_shortmess(ax, msg));*/
        croak("Usage: warnings::%s(%s)", sub, has_message ? "[category,] 'message'" : "[category]");
#endif
    }
    if (has_message) {
        message = items == 1 ? ST(0) : ST(1);
        if (SvREADONLY(message))
            message = newSVpvn(SvPVX(message), SvCUR(message));
        items--;
    } else {
        message = newSVpvs("");
    }
    if (items > 0) {
        if (SvOBJECT(ST(0))) {
            category = HvNAME(SvSTASH(ST(0)));
            is_obj = 1;
        } else if (SvPOK(ST(0))) {
            category = SvPVX(ST(0));
        } else {
            category = NULL;
#ifdef USE_PP_CARP
            PUSHMARK(SP);
            mXPUSHs(newSVpvs("not an object"));
            PUTBACK;
            call_pv("warnings::Croaker", G_DISCARD);
            SPAGAIN;
#else
            croak_sv(carp_shortmess(ax, newSVpvs("not an object")));
#endif
        }
    } else {
        /* when called from pp warnings::* then caller 0, else just curcop */
        const PERL_CONTEXT *cx = caller_cx(0, NULL);
        category = HvNAME(CopSTASH(cx ? cx->blk_oldcop : PL_curcop));
    }

    w = Perl_warnings_lookup(category, strlen(category));
    if (!w) {
        SV *msg = newSVpvs("");
        if (items > 0)
            sv_catpvf(msg, "Unknown warnings category '%s'", category);
        else
            sv_catpvf(msg, "package '%s' not registered for warnings", category);
#ifdef USE_PP_CARP
        PUSHMARK(SP);
        mXPUSHs(msg);
        PUTBACK;
        call_pv("warnings::Croaker", G_DISCARD);
        SPAGAIN;
#else
        croak_sv(carp_shortmess(ax, msg));
#endif
    }

    if (is_obj) {
        /* walk the callstack and find category */
	SV *eval = newSVpvs("my ($i, $pkg) = (2);\n"
"  while (do { { package DB; $pkg = (caller($i++))[0] } } ) {\n"
"    last unless @DB::args && $DB::args[0] =~ /^");
        sv_catpv(eval, category);
        sv_catpvs(eval, "=/;} $i");
        if (eval_sv(eval, G_SCALAR)) { SPAGAIN; i = TOPi - 2; }
        else i = 0;
#ifdef DEBUGGING
        if (DEBUG_v_TEST_)
            Perl_deb("warnings::%s is_obj => cx_depth=%d\n", sub, i);
#endif
        SvREFCNT_dec(eval);
    } else {
#ifdef USE_PP_CARP
        eval_sv(newSVpvs("require Carp;"), G_DISCARD);
        PUSHMARK(SP);
        PUTBACK;
        i = call_pv("Carp::short_error_loc", G_SCALAR);
        SPAGAIN;
        if (i)
            i = (int)TOPi;
        DEBUG_v(deb("Carp::short_error_loc: %d\n", i));
#else
        /* TODO Still buggy, off-by-one
           i = short_error_loc(); */
        i = long_error_loc();
        DEBUG_v(deb("long_error_loc: %d\n", i));
#endif
    }

    if (i == 0) /* A XS speciality */
        old_warnings = PL_curcop->cop_warnings;
    else if ((cx = caller_cx(i, NULL)))
        old_warnings = cx->blk_oldcop->cop_warnings;
    else
        old_warnings = pWARN_NONE;

    if  (old_warnings == pWARN_NONE)
        mask = newWSVpvh(WARN_NONEstring);
    else if (old_warnings == pWARN_STD && !(PL_dowarn & G_WARN_ON))
        mask = newWSVpvh(WARN_DEFAULTstring);
    else if (old_warnings == pWARN_ALL ||
             (old_warnings == pWARN_STD && (PL_dowarn & G_WARN_ON))) {
        const struct Perl_warnings *w_all = Perl_warnings_lookup("all", 3);
        HV * const bits = get_hv("warnings::_Bits", 0);
        if (bits && HvTOTALKEYS(bits))
            mask = newWSV(w_all->bits, SvCUR(((struct Perl_warnings_dyn*)w_all)->base));
        else
            mask = newWSVpvh(w_all->bits);
    }
    else {
        assert(!specialWARN(old_warnings));
        mask = newSVpvn((char *) (old_warnings + 1), old_warnings[0]);
    }
#ifdef DEBUGGING
    if (DEBUG_v_TEST_) {
        SV *dsv = newSVpvn("", 80);
        Perl_deb("warnings::%s %s %d %s\n", sub, category, i,
                 pv_display( dsv, SvPVX(mask), SvCUR(mask), SvCUR(mask), 80));
        SvREFCNT_dec(dsv);
    }
#endif
    if (flags & WFATAL) {
        const char* m = SvPVX(mask);
        results_0 = IsSet(m, w->offset + WFATAL - 1);
        if (w->offset && !results_0) results_0 = IsSet(m, WFATAL - 1);
    }
    if (flags & WNORMAL) {
        const char* m = SvPVX(mask);
        results_1 = IsSet(m, w->offset + WNORMAL - 1);
        if (w->offset && !results_1) results_1 = IsSet(m, WNORMAL - 1);
    }
    SvREFCNT_dec(mask);
    /* &enabled and &fatal_enabled */
    if (!has_message)
        return results_0 ? results_0 : results_1;
    /* &warnif, and the category is neither enabled as warning nor as fatal */
    if (flags == (WNORMAL | WFATAL | WMESSAGE) && !(results_0 | results_1))
        return 0;
    if (results_0) {
#ifdef USE_PP_CARP
        PUSHMARK(SP);
        XPUSHs(message);
        PUTBACK;
        call_pv("warnings::Croaker", G_DISCARD);
        SPAGAIN;
#else
        croak_sv(carp_longmess(ax, message));
#endif
    }
    /* will always get here for &warn. will only get here for &warnif if the
       category is enabled */
#ifdef USE_PP_CARP
    {
        if (is_obj)
            eval_sv(newSVpvs("require Carp;"), G_DISCARD);
        PUSHMARK(SP);
        mXPUSHi(i);
        XPUSHs(message);
        PUTBACK;
        call_pv("Carp::ret_summary", G_SCALAR);
        SPAGAIN;
        warn_sv(TOPs);
    }
#else
    warn_sv(carp_shortmess(ax, message));
#endif
    return 1;
}

/* sv_magic_set ${^WARNINGS_BITS} = mask */
static void
_set_warn_bits(SV* mask, const char *func, const char* arg) {
#ifdef DEBUGGING
    if (DEBUG_v_TEST_) {
        SV *dsv = newSVpvn("", 80);
        Perl_deb("warnings::%s %s %s\n", func, arg,
                 pv_display( dsv, SvPVX(mask), SvCUR(mask), SvCUR(mask), 80));
        SvREFCNT_dec(dsv);
    }
#else
    PERL_UNUSED_ARG(func);
    PERL_UNUSED_ARG(arg);
#endif
    if (PL_dowarn & G_WARN_ALL_MASK) return;

    /* we always call it with a string */
    if (!SvPOK(mask)) {
        PL_compiling.cop_warnings = pWARN_STD;
        return;
    }
    if (memEQs(SvPVX(mask), WARNsize, WARN_ALLstring)) {
        if (!specialWARN(PL_compiling.cop_warnings))
            PerlMemShared_free(PL_compiling.cop_warnings);
        PL_compiling.cop_warnings = pWARN_ALL;
        PL_dowarn |= G_WARN_ONCE;
    } else if (memEQs(SvPVX(mask), WARNsize, WARN_NONEstring)) {
        if (!specialWARN(PL_compiling.cop_warnings))
            PerlMemShared_free(PL_compiling.cop_warnings);
        PL_compiling.cop_warnings = pWARN_NONE;
    } else {
        PL_compiling.cop_warnings
            = Perl_new_warnings_bitfield(aTHX_ PL_compiling.cop_warnings,
                                         SvPVX(mask), SvCUR(mask));
        if (isWARN_on(PL_compiling.cop_warnings, WARN_ONCE))
            PL_dowarn |= G_WARN_ONCE;
    }
}

static SV*
_do_bits(SV *mask, const SV * const word, int fatal, int nonfatal) {
    if (SvPOK(word)) {
        const struct Perl_warnings *w
            = Perl_warnings_lookup(SvPVX_const(word), SvCUR(word));
        if (w) {
            SV *tmp = newWSVpv(w->bits);
            do_vop(OP_BIT_OR, mask, mask, tmp);
            SvREFCNT_dec(tmp);
            if (fatal) {
                tmp = newWSVpv(w->deadbits);
                do_vop(OP_BIT_OR, mask, mask, tmp);
                SvREFCNT_dec(tmp);
            }
            if (nonfatal) {
                U8 *p;
                STRLEN j;
                SV *tmp = newWSVpvs("");
                SV *dead = newWSVpv(w->deadbits);
                SV *three = newWSVpvs("\3");
                do_vop(OP_BIT_OR, tmp, dead, three);
                /* scomplement is static */
                for (p=(U8*)SvPVX(tmp), j=0; j<SvCUR(tmp); j++) {
                    const U8 c = *p;
                    *p++ = ~c;
                }
                do_vop(OP_BIT_AND, mask, mask, tmp);
                SvREFCNT_dec(three);
                SvREFCNT_dec(dead);
                SvREFCNT_dec(tmp);
            }
            return mask;
        } else {
#ifdef USE_PP_CARP
            dSP;
#else
            dORIGMARK;
            I32 ax = TOPMARK - 1; /* ??? Test with Carp XS */
#endif
            SV *msg = newSVpvs("Unknown warnings category '");
            sv_catsv(msg, (SV * const)word);
            sv_catpvs(msg, "'");
            /* But here the fallback to pp warnings::Croaker does not work */
#ifdef USE_PP_CARP
            PUSHMARK(SP);
            mXPUSHs(msg);
            PUTBACK;
            call_pv("warnings::Croaker", G_DISCARD);
            SPAGAIN;
#else
            croak_sv(carp_shortmess(ax, msg));
#endif
            return NULL;
        }
    }
    return NULL;
}


MODULE = warnings		PACKAGE = warnings
PROTOTYPES: DISABLE

void
_bits (mask, ...)
     SV *mask
PREINIT:
    int i;
    int fatal = 0, no_fatal = 0;
PPCODE:
    if (!SvPOK(mask))
        mask = sv_2mortal(newWSVpvh(WARN_NONEstring));
    for (i=1; i<items; i++) {
        SV *word = ST(i);
        if (SvPOK(word)) {
            if (memEQs(SvPVX(word), SvCUR(word), "FATAL")) {
                fatal = 1;
                no_fatal = 0;
            } else
            if (memEQs(SvPVX(word), SvCUR(word), "NONFATAL")) {
                fatal = 0;
                no_fatal = 1;
            } else {
                mask = _do_bits(mask, word, fatal, no_fatal);
            }
        }
    }
    TOPs = mask;
    XSRETURN(1);

void
bits (...)
PPCODE:
    PUSHMARK(SP);
    mXPUSHs(&PL_sv_undef);
    if (!items)
        mXPUSHs(newSVpvs("all"));
    PUTBACK;
    if (call_pv("warnings::_bits", G_SCALAR)) {
        SPAGAIN;
        XSRETURN(1);
    } else
        XSRETURN_UNDEF;

void
import (klass, ...)
    SV* klass
PREINIT:
    SV *mask;
    struct Perl_warnings *w_all = NULL;
PPCODE:
    if (!SvPOK(klass))
        croak_xs_usage(cv,  "class, ...");
    /* mask = ${^WARNING_BITS} // ($^W ? $Bits{all} : $DEFAULT); */
    if (specialWARN(PL_compiling.cop_warnings)) {
        if (PL_dowarn & G_WARN_ON || PL_compiling.cop_warnings == pWARN_ALL) {
            w_all = Perl_warnings_lookup("all", 3);
            mask = newWSVpv(w_all->bits);
        } else if (PL_compiling.cop_warnings == pWARN_NONE) {
            mask = newWSVpvh(WARN_NONEstring);
        } else {
            mask = newWSVpvh(WARN_DEFAULTstring);
        }
    } else
        mask = newSVpvn((char*)((STRLEN*)PL_compiling.cop_warnings+1),
                        *PL_compiling.cop_warnings);

    if (IsSet(SvPVX(mask), 0)) {
        SV* tmp;
        if (!w_all) w_all = Perl_warnings_lookup("all", 3);
        tmp = newWSVpv(w_all->bits);
        do_vop(OP_BIT_OR, mask, mask, tmp);
        SvREFCNT_dec(tmp);
        if (IsSet(SvPVX(mask), 1)) {
            tmp = newWSVpv(w_all->deadbits);
            do_vop(OP_BIT_OR, mask, mask, tmp);
            SvREFCNT_dec(tmp);
        }
    }
    if (items > 1) {
        int i;
        SV *word;
        int fatal = 0, no_fatal = 0;
        for (i=1; i<items; i++) {
            word = ST(i);
            if (SvPOK(word)) {
                if (memEQs(SvPVX(word), SvCUR(word), "FATAL")) {
                    fatal = 1;
                    no_fatal = 0;
                }
                else if (memEQs(SvPVX(word), SvCUR(word), "NONFATAL")) {
                    fatal = 0;
                    no_fatal = 1;
                } else {
                    mask = _do_bits(mask, word, fatal, no_fatal);
                }
            }
        }
        word = ST(1);
        /* push @_, 'all' if @_==1 && ( $_[0] eq 'FATAL' || $_[0] eq 'NONFATAL' ); */
        if (items == 2 && SvPOK(word)) {
            SV* all = newSVpvs("all");
            if (memEQs(SvPVX(word), SvCUR(word), "FATAL"))
                mask = _do_bits(mask, all, 1, 0);
            else if (memEQs(SvPVX(word), SvCUR(word), "NONFATAL"))
                mask = _do_bits(mask, all, 0, 1);
            SvREFCNT_dec(all);
        }
        _set_warn_bits(mask, "import", SvPVX(word));
        SvREFCNT_dec(mask);
        XSRETURN_UNDEF;
    } else {
        SV *tmp;
        if (!w_all) w_all = Perl_warnings_lookup("all", 3);
        tmp = newWSVpv(w_all->bits);
        do_vop(OP_BIT_OR, mask, mask, tmp);
        SvREFCNT_dec(tmp);
        _set_warn_bits(mask, "import", "");
        mXPUSHs(mask);
        XSRETURN(1);
    }

void
unimport (klass, ...)
   SV* klass
PREINIT:
    SV *mask;
    int i;
    struct Perl_warnings *w_all = NULL;
PPCODE:
    if (!SvPOK(klass))
        croak_xs_usage(cv,  "class, ...");
    /* mask = ${^WARNING_BITS} // ($^W ? $Bits{all} : $DEFAULT); */
    if (specialWARN(PL_compiling.cop_warnings)) {
        if (PL_dowarn & G_WARN_ON || PL_compiling.cop_warnings == pWARN_ALL) {
            w_all = Perl_warnings_lookup("all", 3);
            mask = newWSVpv(w_all->bits);
        } else if (PL_compiling.cop_warnings == pWARN_NONE) {
            mask = newWSVpvh(WARN_NONEstring);
        } else {
            mask = newWSVpvh(WARN_DEFAULTstring);
        }
    } else
        mask = newSVpvn((char*)((STRLEN*)PL_compiling.cop_warnings+1),
                        *PL_compiling.cop_warnings);

    if (IsSet(SvPVX(mask), 0)) {
        SV *tmp;
        if (!w_all) w_all = Perl_warnings_lookup("all", 3);
        tmp = newWSVpv(w_all->bits);
        do_vop(OP_BIT_OR, mask, mask, tmp);
        SvREFCNT_dec(tmp);
        if (IsSet(SvPVX(mask), 1)) {
            tmp = newWSVpv(w_all->deadbits);
            do_vop(OP_BIT_OR, mask, mask, tmp);
            SvREFCNT_dec(tmp);
        }
    }
    /* push @_, 'all' if !@_ || @_==1 && $_[0] eq 'FATAL'; */
    if ((items == 1) ||
        (items == 2 && (SvPOK(ST(1)) && memEQs(SvPVX(ST(1)), SvCUR(ST(1)), "FATAL"))))
    {
        mPUSHs(newSVpvs("all"));
        ax--;
        items++;
    }
    for (i=1; i<items; i++) {
        SV *word = ST(i);
        if (!SvPOK(word)) continue;
        if (memEQs(SvPVX(word), SvCUR(word), "FATAL"))
            continue;
        else {
            const struct Perl_warnings *w
                = Perl_warnings_lookup(SvPVX(word), SvCUR(word));
            if (w) { /* $mask &= ~($catmask | $DeadBits{$word} | $All); */
                STRLEN j; U8 *p;
                SV *catmask = newWSVpv(w->bits);
                SV *dead    = newWSVpv(w->deadbits);
                SV *three   = newWSVpvs("\3");
                do_vop(OP_BIT_OR, catmask, catmask, dead);
                do_vop(OP_BIT_OR, catmask, catmask, three); /* $All */
                for (p=(U8*)SvPVX(catmask), j=0; j<SvCUR(catmask); j++) {
                    const U8 c = *p;
                    *p++ = ~c;
                }
                do_vop(OP_BIT_AND, mask, mask, catmask);
                SvREFCNT_dec(three);
                SvREFCNT_dec(dead);
                SvREFCNT_dec(catmask);
            } else {
                SV *msg = newSVpvs("Unknown warnings category '");
                sv_catsv(msg, word);
                sv_catpvs(msg, "'");
#ifdef USE_PP_CARP
                PUSHMARK(SP);
                mXPUSHs(msg);
                PUTBACK;
                call_pv("warnings::Croaker", G_DISCARD);
                SPAGAIN;
#else
                croak_sv(carp_shortmess(ax, msg));
#endif
            }
        }
    }
    _set_warn_bits(mask, "unimport", items > 1 ? SvPVX(ST(1)) : "");
    mXPUSHs(mask);
    XSRETURN(1);

void
_chk (SV *sub, IV flags, ...)
PPCODE:
    if (_chk(SvPVX(sub), flags, ax+2))
        XSRETURN_YES;
    else
        XSRETURN_NO;

#if 0

void
enabled (...)
PPCODE:
    if (_chk("enabled", WNORMAL, ax))
        XSRETURN_YES;
    else
        XSRETURN_NO;

void
fatal_enabled (...)
PPCODE:
    if (_chk("fatal_enabled", WFATAL, ax))
        XSRETURN_YES;
    else
        XSRETURN_NO;

void
warn (...)
PPCODE:
    if (_chk("warn", WFATAL|WMESSAGE, ax))
        XSRETURN_YES;
    else
        XSRETURN_NO;

void
warnif (...)
PPCODE:
    if (_chk("warnif", WNORMAL|WFATAL|WMESSAGE, ax))
        XSRETURN_YES;
    else
        XSRETURN_NO;

#endif

void
register_categories (...)
PREINIT:
    int i;
PPCODE:
    /* check if name is registered (const key).
       if not, add key and also add bit to Bits{all} and DeadBits{all} */
    for (i=0; i<items; i++) {
        SV *name = ST(i);
        char* n;
        struct Perl_warnings *w;
        STRLEN l = SvCUR(name);
        if (!SvPOK(name)) continue;
        n = SvPVX(name);
        w = Perl_warnings_lookup(n, l);
        if (!w) { /* oops, a new category. Add to dynamic %_Bits */
            struct Perl_warnings_dyn* wd = NULL;
            HV * const bith = get_hv("warnings::_Bits", GV_ADD);
            SV *last_bitsv  = get_sv("warnings::LAST_BIT", 0);
            IV last_bit = SvIVX(last_bitsv);
            IV offset = last_bit + 1;
            SV *bytes = get_sv("warnings::BYTES", 0);
            SV *bits = newWSVpvs("");
            SV *dead = newWSVpvs("");
            U32 nl = SvIVX(bytes);
            char *b, *d;

            /* with elements in %_Bits its guaranteed to return a dynamic wd,
               otherwise the static w, which will ignore from now on */
            if (HvTOTALKEYS(bith)) {
                wd = (struct Perl_warnings_dyn *)Perl_warnings_lookup("all", 3);
            }
            
            SvGROW(bits, nl*2);
            SvGROW(dead, nl);
            SvCUR_set(bits, nl);
            SvCUR_set(dead, nl);
            b = SvPVX(bits);
            d = SvPVX(dead);
            b[ Off(last_bit) ] |= Bit(last_bit);
            d[ Off(offset) ]   |= Bit(offset);
            sv_catsv(bits, dead);
            sv_upgrade(bits, SVt_PVIV);
            SvIV_set(bits, last_bit);
            SvREADONLY_off(bith);
            hv_store_ent(bith, name, bits, 0);
#ifdef DEBUGGING
            if (DEBUG_v_TEST_) {
                SV *dsv = newSVpvn("", 80);
                Perl_deb("warnings::register_categories %s %s\n", n,
                         pv_display( dsv, SvPVX(bits), SvCUR(bits), WARN_MAX_BYTES, 80));
                SvREFCNT_dec(dsv);
            }
#endif
            /* also extend "all" */
            if (!wd) { /* fresh */
                bits = newWSVpvs("");
                SvGROW(bits, nl*2);
                Move(WARN_ALLstring, SvPVX_const(bits), nl, char);
                Move(WARN_DEADALLstring, SvPVX_const(dead), nl, char);
                SvCUR_set(bits, nl);
                b = SvPVX(bits);
                d = SvPVX(dead);
                b[ Off(last_bit) ] |= Bit(last_bit);
                d[ Off(offset) ]   |= Bit(offset);
                sv_catsv(bits, dead);
                sv_upgrade(bits, SVt_PVIV);
                SvIV_set(bits, 0);
                hv_store(bith, "all", 3, bits, 0);
            } else { /* existing $_Bits{all} */
                U32 l = SvCUR(wd->base) / 2;
                bits = wd->base;
                if (nl > l) {
                    SvGROW(bits, nl*2);
                    SvCUR_set(bits, nl);
                    wd->bits = SvPVX(bits);
                    Move(wd->deadbits, wd->bits + l, nl, char);
                    wd->deadbits = wd->bits + nl;
                }
                wd->bits[   Off(last_bit) ] |= Bit(last_bit);
                wd->deadbits[ Off(offset) ] |= Bit(offset);
            }
            SvREADONLY_on(bith);

            last_bit = offset + 1;
            if (Off(last_bit) > SvIVX(bytes)) {
                SvREADONLY_off(bytes);
                SvIV_set(bytes, Off(last_bit));
                SvREADONLY_on(bytes);
            }
            SvREADONLY_off(last_bitsv);
            SvIV_set(last_bitsv, last_bit);
            SvREADONLY_on(last_bitsv);
            SvREFCNT_dec(dead);
#ifdef DEBUGGING
            if (DEBUG_v_TEST_) {
                SV *dsv = newSVpvn("", 80);
                Perl_deb(" all=%s, BYTES=%ld, LAST_BIT=%ld\n",
                         pv_display( dsv, SvPVX(bits), SvCUR(bits), WARN_MAX_BYTES, 80),
                         SvIVX(bytes), last_bit);
                SvREFCNT_dec(dsv);
            }
#endif
            /* Do we need to update ${^WARNING_BITS}/cop_warnings also? */
            /* _set_warn_bits(newWSV(wd->bits, SvIVX(bytes)), "register_categories", n); */
        }
    }
    XSRETURN_UNDEF;

void
KEYS()
PREINIT:
    int i;
    const int size = TOTAL_KEYWORDS;
    char *s = (char *)stringpool;
    HV * const bits = get_hv("warnings::_Bits", 0);
PPCODE:
    /* Note: This is highly gperf dependent! */
    EXTEND(sp, size);
    for (i=0; i<size; i++) {
        int l = strlen(s);
        mPUSHp(s, l);
        s += l+1;
    }
    if (bits) {
        I32 len = HvTOTALKEYS(bits);
        EXTEND(sp, len);
        /* And now the dynamic bits */
        hv_iterinit(bits);
        for (i = 0; i < len; i++) {
            HE *he = hv_iternext(bits);
            SV *key = hv_iterkeysv(he);
            if (strnNE(SvPVX(key), "all", SvCUR(key)))
                PUSHs(key);
        }
    }

# in fact a HASHOBJ*
void
TIEHASH(classname)
    SV * classname
PREINIT:
    SV * rv;
    SV * tmp;
CODE:
    rv = sv_newmortal();
    tmp = classname;
    *SP = rv;
    sv_setref_uv(rv, SvPVX(tmp), 0);
    return;

void
FIRSTKEY(self)
    HASHOBJ *self
PREINIT:
    const char *s = (const char *)stringpool;
    size_t len;
    STATIC_ASSERT_STMT(sizeof(stringpool_contents) > 1);
CODE:
    len = strlen(s);
    *self = len + 1;
    *SP = sv_2mortal(newSVpvn(aTHX_ s, len));
    return;

void
NEXTKEY(self, lastkey)
    HASHOBJ *self
    SV *lastkey
PREINIT:
    SV * RETVAL;
PPCODE:
    PERL_UNUSED_VAR(lastkey);
    SP++;
    PUTBACK;
    /* bounds check to avoid running off the end of stringpool */
    if (*self < sizeof(stringpool_contents)) {
        const char * key = (const char*)stringpool + *self;
        size_t len = strlen(key);
        *self += len + 1;
        RETVAL = sv_2mortal(newSVpvn(aTHX_ key, len));
    }
    else
        RETVAL = &PL_sv_undef;
    *SP = RETVAL;
    return;

void
FETCH(self, category)
    SV* self
    SV* category
ALIAS:
    EXISTS = 1
PREINIT:
    const char *str = SvPVX(category);
    const IV len = SvCUR(category);
    const struct Perl_warnings *w = warnings_const_lookup(str, len);
    const char* name = HvNAME(SvSTASH(SvRV(self)));
    const bool isdead = name && strEQ(name, "warnings::_DeadBits");
PPCODE:
    if (w) {
        if (ix)
            XSRETURN_YES;
        else {
            SV *bytes = get_sv("warnings::BYTES", 0);
            ST(0) = sv_2mortal(newWSV(isdead ? w->deadbits : w->bits, SvIVX(bytes)));
            XSRETURN(1);
        }
    } else {
        SV **bit;
        HV * const bits = get_hv("warnings::_Bits", 0);
        if (bits) {
            SvREADONLY_off(bits);
            if ((bit = hv_fetch(bits, str, len, FALSE))) {
                SvREADONLY_on(bits);
                if (ix)
                    XSRETURN_YES;
                else {
                    STRLEN len = SvCUR(*bit);
                    ST(0) = sv_2mortal(newSVpvn(SvPVX_const(*bit)+(isdead ? len/2 : 0),
                                                len/2));
                    XSRETURN(1);
                }
            }
            SvREADONLY_on(bits);
        }
    }
    XSRETURN_UNDEF;

BOOT:
{
    GV *last_bit = gv_fetchpv("warnings::LAST_BIT", GV_ADDMULTI, SVt_IV);
    GV *bytes    = gv_fetchpv("warnings::BYTES", GV_ADDMULTI, SVt_IV);
    GvSV(last_bit) = newSViv(WARN_LAST_BIT);
    SvREADONLY_on(GvSV(last_bit));
    GvSV(bytes)    = newSViv(WARNsize);
    SvREADONLY_on(GvSV(bytes));
}

